# Nombre de la aplicación
spring.application.name=PodStream

# Configuración de la conexión a la base de datos MySQL
spring.datasource.url=jdbc:mysql://localhost:3306/podstream
spring.datasource.username=${DB_USERNAME:root}
spring.datasource.password=${DB_PASSWORD:}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# Configuración de Hibernate y JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Configuración de la conexión SMTP
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=${MAIL_USERNAME:podstreamstore@gmail.com}
spring.mail.password=${MAIL_PASSWORD:sjmt pdzc vset nrjh}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.debug=true

# Configuración de HikariCP (pool de conexiones)

# Número máximo de conexiones en el pool. Este valor debe ser ajustado
# según la carga esperada de la aplicación y las capacidades de la base de datos.
spring.datasource.hikari.maximum-pool-size=20

# Número mínimo de conexiones que se mantendrán en el pool,
# incluso si están inactivas. Este valor debe ser ajustado
# para balancear la latencia y el uso de recursos.
spring.datasource.hikari.minimum-idle=5

# Tiempo máximo (en milisegundos) que una conexión puede estar inactiva
# en el pool antes de ser eliminada. Un valor más bajo puede liberar recursos,
# pero puede aumentar la latencia para nuevas conexiones.
spring.datasource.hikari.idle-timeout=60000

# Tiempo máximo (en milisegundos) que una solicitud de conexión
# puede estar esperando en la cola antes de lanzar una excepción.
# Este valor debe ser ajustado según la latencia aceptable para la aplicación.
spring.datasource.hikari.connection-timeout=30000

# Tiempo máximo de vida (en milisegundos) de una conexión en el pool.
# Después de este tiempo, la conexión será eliminada y reemplazada
# por una nueva. Esto ayuda a mitigar problemas de conexión a largo plazo.
spring.datasource.hikari.max-lifetime=1800000

# Configuración del servidor
server.address = 0.0.0.0
server.port=8088
server.forward-headers-strategy=native

# Configuración de Actuator y Prometheus
management.endpoints.web.exposure.include=health,info,metrics,prometheus,loggers
management.endpoint.prometheus.enabled=true
management.endpoint.health.show-details=always
management.metrics.tags.application=${spring.application.name}

# Configuración de logging
debug=true
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.com.podstream=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE
logging.level.org.springframework.data=DEBUG
logging.level.org.hibernate.orm.jdbc.bind=TRACE

# Configuración de Jira
JIRA_URL=https://podstreamstore.atlassian.net
JIRA_USERNAME=podstreamstore@gmail.com
JIRA_API_TOKEN=ATATT3xFfGF0Yjijr4Ze4XXzfRIny1b-fWFWVt5WaTWqgU5C3hwyV2l7hQRRj6ZKAi0sBAUfFJGIZkgmrfhqmTXPBeSqgIN1hPRK4VxlM2IcTwOTvdUS4QXeCkvgx0997Dzx2zES_vHoNxsIa5pCOZyjo9tCAJloD-51X9Nw7dxRiXJxtUftQ3U=19CA6D19
JIRA_PROJECT_KEY=POD

# Configuración jwt
jwt.secret=bWktcHJveWVjdG8tcG9kc3RyZWFtLWVzLWluY3JlaWJsZS15LWVzdGEtZXMtbWktY2xhdmUtc2VjcmV0YS0yMDI1
jwt.expiration=86400000

# Configuración de Swagger
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui
springdoc.swagger-ui.url=/api-docs

# Configuración de Redis
spring.redis.host=localhost
spring.redis.port=6379

# Configuracion Elasticsearch
spring.elasticsearch.uris=http://localhost:9200
